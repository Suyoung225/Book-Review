## 48. 스트림 병렬화는 주의해서 적용하라

### 병렬화로 성능이 악화되는 경우

```java
import java.math.BigInteger;
import java.util.stream.Stream;

import static java.math.BigInteger.*;

public class EffectiveJava {
    static Stream<BigInteger> primes() {
        return Stream.iterate(TWO, BigInteger::nextProbablePrime);
    }

    public static void main(String[] args) {
        primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
                .parallel()
                .filter(mersenne -> mersenne.isProbablePrime(50))
                .limit(20)
                .forEach(mp -> System.out.println(mp.bitLength() + ": " + mp));
    }
}
```

45장에 나온 메르센 소수 예제에 `parallel()` 메서드를 추가하여 스트림 병렬화를 하였다. <br>
오랫동안 아무것도 출력하지 못하면서 CPU만 많이 잡아 먹는다.
<br>
그 이유는 스트림이 이 파이프라인을 병렬화하는 방법을 찾아내지 못했기 때문이다. 
<br>
>**데이터 소스가 Stream.iterate거나 중간 연산으로 limit을 사용하면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.**


위 예시는 두 문제를 모두 지니고 있다.
<br>
limit이 문제가 되는 이유는 아래와 같다.<br>
병렬화는 limit을 다룰 때 CPU 코어가 남는다면 원소를 몇 개 더 처리한 후에 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정한다. <br>
위 예제에서 마지막 20번 째 계산이 수행될 때 코어가 3개가 남는다면 각각 21, 22, 23번째 메르센 소수를 구하게 된다. 하지만 새롭게 메르센 소수를 찾을 때마다 그 전 소수를 찾을 때보다 두 배 정도 오래 걸리기 때문에 , 21, 22, 23번째 메르센 소수를 구할 때 20번째 계산보다 2, 4, 8배의 시간이 더 필요하다. 
또 다르게 말하면, 원소 하나를 계산하는 비용이 그 이전까지의 원소를 전부 계산한 비용을 합친 것만큼 든다는 뜻이다. 
<br>
따라서 20번 계산이 끝나더라도 이 모든 계산이 끝날 때까지 기다려야 한다. 
<br>
위 예시는 스트림 병렬화는 성능이 오히려 끔찍하게 나빠진 경우를 보여준다.

### 병렬화의 효과가 좋은 경우

> 스트림의 소스가 `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap`의 인스턴스거나 `배열`, `int 범위`, `long 범위`일 때 병렬화의 효과가 가장 좋다.

이유:
- 데이터를 원하는 크기로 정확하고 쉽게 나눌 수 있어서 작업을 다수의 스레드에 분배하기에 좋다는 특징이 있다.
- 원소들을 순차적으로 실행할 때 참조 지역성이 뛰어나다. 특히 기본 타입 배열은 참조가 아닌 데이터 자체가 메모리에 연속해서 저장되기 때문에 참조 지역성이 가장 뛰어나다.

> **참조 지역성(locality of reference)**<br>
동일한 값 또는 해당 값에 관계된 스토리지 위치가 자주 액세스되는 특성 <br>
데이터 접근이 시간적, 공간적으로 가깝게 일어나는 것 <br>

캐시의 지역성 <br>
캐시의 적중율(Hit-rate)를 극대화 시키기 위해 캐시 데이터는 지역성을 가져야 함

> 참조 지역성 종류<br>
공간(spatial) 지역성 : 특성 클러스터의 기억 장소들에 대해 참조가 집중적으로 이루어지는 경향으로, 참조된 메모리 근처의 메모리를 참조합니다.<br>
시간(temporal) 지역성 : 최근 사용되었던 기억 장소들이 집중적으로 액세스되는 경향으로, 참조했던 메모리는 빠른 시간에 다시 참조될 확률이 높습니다. <br>
순차(sequential) 지역성 : 데이터가 순차적으로 액세스되는 경향으로, 프로그램 내의 명령어가 순차적으로 구성되어 있다는 것이 대표적인 경우입니다. 공간 지역성에 편입되어 설명되기도 합니다.

참조들이 가리키는 실제 객체가 메모리에서 서로 떨어져 있으면 참조 지역성이 나빠지고, 참조 지역성이 낮으면 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리며 시간을 낭비한다. 따라서 참조 지역성은 다량의 데이터를 처리하는 벌크 연산을 병렬화할 때 아주 중요한 요소로 작용한다.

### 종단 연산의 동작 방식에 따른 병렬 수행 효율


### 결과가 잘못되거나 오작동 발생 - safety failure
병렬화한 메르센 소수 예제에서도 설령 실행이 완료되더라도 출력된 소수의 순서가 올바르지 않을 수 있다. <br>
위 메르센 소수 예시에서 limit(10)으로 변경하여 실행하면 아래와 같은 결과가 나왔다. <br>
> 17: 131071  <br>
3: 7 <br>
61: 2305843009213693951 <br>
89: 618970019642690137449562111 <br>
31: 2147483647 <br>
19: 524287 <br>
13: 8191 <br>
2: 3 <br>
5: 31 <br>
7: 127 <br>

출력 순서를 보장하고 싶다면 `forEach`를 `forEachOrdered`로 바꿔주면 된다.


### 스트림 병렬화로 성능 최적화
**스트림 병렬화는 오직 성능 최적화 수단임을 잊지 말자**

성능이 향상 될 지 추정하는 간단한 방법으로는 스트림 안의 원소 수와 원소당 수행되는 코드 줄 수를 곱해서 최소 수십만이 되어야 성능 향상을 맛볼 수 있다.

조건이 잘 갖춰지면 병렬화로 거의 프로세서 코어 수에 비례하는 성능 향상을 할 수 있다.

무작위 수들로 이뤄진 스트림을 병렬화하려면 `SplittableRandom` 인스턴스를 활용하자. `ThreadLocalRandom`은 단일 스레드에서 쓰고자 만들어졌고, `Random`은 모든 연산을 동기화하여 병렬 처리 시 최악의 성능을 보인다. 반면 `SplittableRandom` 은 병렬화 처리를 위해 만들어졌다.


***

### 참고 자료
Effective Java 3/E - Joshua Bloch <br>

참조 지역성:
https://jwprogramming.tistory.com/18
