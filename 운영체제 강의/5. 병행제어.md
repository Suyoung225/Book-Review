# Race Condition
1. 커널 수행 중 인터럽트 발생 시
![272487374-67099c99-0464-43be-8c20-6301bcfd59f7 1 -min](https://github.com/Suyoung225/Book-Review/assets/87157566/aa46cba5-4b14-47fa-b187-ffc442d9cefc)



2. Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우

두 프로세스의 address space 간에는 데이터 공유가 일어나지 않지만, system call을 하는 동안에는 kernal address space의 데이터에 접근하게 됨 <br>
이 작업 중간에 CPU를 preempt(선점) 해가면 race condition 발생 <br>
해결책: 커널 모드에서는 CPU preempt하지 않고, 유저 모드로 돌아갈 때 preempt

3. Multiprocessor
- 2번처럼 interrupt enable/disable로 해결 안 됨
- 한 번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법 (CPU를 하나만 사용하게 하는 방법 -> 비효율)
- 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlock 하는 방법


# Process Synchronization


